#include <locale.h>
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <random>
#include <chrono>
#include <vector>
#include <atomic>

class ComputerRoom {
private:
    std::mutex mtx;
    std::condition_variable cv;

    const int capacity = 20;
    const int total_ks40 = 30;
    const int total_ks44 = 24;
    const int need_ks40 = 15; // половина 30
    const int need_ks44 = 12; // половина 24

    // Текущее состояние комнаты (все изменяются под mtx)
    int occupancy = 0;
    int present_ks40 = 0;
    int present_ks44 = 0;
    int current_group = 0; // 0 - пусто/нет пары, 1 - КС-40, 2 - КС-44
    bool class_in_session = false;

    // поток, моделирующий само занятие (detached)
    // (используем локальную временную std::thread в start_class_locked)

    std::atomic<bool> stop_flag{ false }; // флаг для остановки всех потоков

    // per-student info
    std::vector<int> visits_ks40;
    std::vector<int> visits_ks44;
    std::vector<bool> in_room_ks40;
    std::vector<bool> in_room_ks44;

    // чтобы не начислять посещение дважды одному студенту в одной паре
    std::vector<bool> attended_this_session_ks40;
    std::vector<bool> attended_this_session_ks44;

    // случайное время ожидания (1 или 2 секунды)
    int get_random_time() {
        static thread_local std::mt19937 gen(std::random_device{}());
        std::uniform_int_distribution<> dis(1, 2);
        return dis(gen);
    }

    bool can_start_class(int group) {
        if (group == 1) return present_ks40 >= need_ks40;
        if (group == 2) return present_ks44 >= need_ks44;
        return false;
    }

    // Запуск пары: вызывается под mtx.
    void start_class_locked(int group) {
        if (class_in_session || stop_flag) return;

        class_in_session = true;
        current_group = group;

        std::cout << "\n=== Началось занятие для группы " << (group == 1 ? "КС-40" : "КС-44")
            << " (в комнате: КС-40=" << present_ks40 << ", КС-44=" << present_ks44 << ") ===\n";

        // Выгнать всех из другой группы (они остаются живыми потоками и вернутся позже)
        if (group == 1) {
            for (int i = 0; i < total_ks44; ++i) {
                if (in_room_ks44[i]) {
                    in_room_ks44[i] = false;
                    present_ks44--;
                    occupancy--;
                    std::cout << "  (выгнан) студент " << i << " из КС-44\n";
                }
                attended_this_session_ks44[i] = false;
            }
            // начисляем посещение тем KС-40, кто уже в комнате
            for (int i = 0; i < total_ks40; ++i) {
                if (in_room_ks40[i] && !attended_this_session_ks40[i]) {
                    visits_ks40[i]++;
                    attended_this_session_ks40[i] = true;
                    std::cout << "  (посещение) студент " << i << " из КС-40 (всего=" << visits_ks40[i] << ")\n";
                }
            }
        }
        else {
            for (int i = 0; i < total_ks40; ++i) {
                if (in_room_ks40[i]) {
                    in_room_ks40[i] = false;
                    present_ks40--;
                    occupancy--;
                    std::cout << "  (выгнан) студент " << i << " из КС-40\n";
                }
                attended_this_session_ks40[i] = false;
            }
            for (int i = 0; i < total_ks44; ++i) {
                if (in_room_ks44[i] && !attended_this_session_ks44[i]) {
                    visits_ks44[i]++;
                    attended_this_session_ks44[i] = true;
                    std::cout << "  (посещение) студент " << i << " из КС-44 (всего=" << visits_ks44[i] << ")\n";
                }
            }
        }

        // Оповестим всех о старте (чтобы вошедшие/ожидающие узнали)
        cv.notify_all();

        // Запускаем поток-преподавателя, который через 5 секунд завершит пару.
        std::thread([this]() {
            std::this_thread::sleep_for(std::chrono::seconds(5));
            if (!stop_flag) {
                // Завершаем пару под mutex
                std::unique_lock<std::mutex> lock(this->mtx);
                if (!this->class_in_session) return; // на всякий случай
                std::cout << "\n=== Завершение занятия для группы " << (this->current_group == 1 ? "КС-40" : "КС-44") << " ===\n";

                // Учитель выводит всех оставшихся (все, кто был в комнате в момент окончания)
                for (int i = 0; i < this->total_ks40; ++i) {
                    if (this->in_room_ks40[i]) {
                        this->in_room_ks40[i] = false;
                        this->present_ks40--;
                        this->occupancy--;
                        // посещение уже начислено при старте/входе
                    }
                }
                for (int i = 0; i < this->total_ks44; ++i) {
                    if (this->in_room_ks44[i]) {
                        this->in_room_ks44[i] = false;
                        this->present_ks44--;
                        this->occupancy--;
                    }
                }

                this->class_in_session = false;
                this->current_group = 0;

                // Сброс флагов attended_this_session (на будущее)
                for (int i = 0; i < this->total_ks40; ++i) this->attended_this_session_ks40[i] = false;
                for (int i = 0; i < this->total_ks44; ++i) this->attended_this_session_ks44[i] = false;

                // Оповестим всех (чтобы ожидающие могли войти)
                lock.unlock();
                this->cv.notify_all();
            }
            }).detach();
    }

public:
    ComputerRoom()
        : visits_ks40(total_ks40, 0),
        visits_ks44(total_ks44, 0),
        in_room_ks40(total_ks40, false),
        in_room_ks44(total_ks44, false),
        attended_this_session_ks40(total_ks40, false),
        attended_this_session_ks44(total_ks44, false) {
    }

    // Метод для остановки всех потоков
    void stop() {
        stop_flag = true;
        cv.notify_all();
    }

    // Метод для входа студента
    void student_behavior(int group, int student_id) {
        while (!stop_flag) {
            // Проверим условие выхода
            {
                std::lock_guard<std::mutex> lock(mtx);
                if ((group == 1 && visits_ks40[student_id] >= 2) ||
                    (group == 2 && visits_ks44[student_id] >= 2)) {
                    // Завершил
                    // std::cout << "Студент " << student_id << " из " << (group==1?"КС-40":"КС-44") << " завершил\n";
                    return;
                }
            }

            // Перед попыткой — жду случайное S (1 или 2) секунд (симулирует решение прийти и ждать)
            int S = get_random_time();
            // Попытка войти: пробуем под мьютексом
            {
                std::unique_lock<std::mutex> lock(mtx);
                if (stop_flag) return;

                // Если сейчас идёт занятие чужой группы, то нельзя войти — будем ждать либо до таймаута S, либо нотификации
                auto deadline = std::chrono::steady_clock::now() + std::chrono::seconds(S);

                // Ждем возможности войти (место и либо нет пары, либо пара нашей группы).
                while (true) {
                    if (stop_flag) return;

                    // если уже закончил за время ожидания
                    if ((group == 1 && visits_ks40[student_id] >= 2) ||
                        (group == 2 && visits_ks44[student_id] >= 2)) return;

                    bool can_enter_now = (occupancy < capacity) && (!class_in_session || current_group == group);

                    if (can_enter_now) {
                        // Входим
                        occupancy++;
                        if (group == 1) { in_room_ks40[student_id] = true; present_ks40++; }
                        else { in_room_ks44[student_id] = true; present_ks44++; }

                        std::cout << "Студент " << student_id << " из группы " << (group == 1 ? "КС-40" : "КС-44")
                            << " вошел (occupancy=" << occupancy << ", КС-40=" << present_ks40 << ", КС-44=" << present_ks44 << ")\n";

                        // Если после входа достигнута половина -> стартуем пару
                        if (!class_in_session && can_start_class(group)) {
                            start_class_locked(group);
                        }

                        // Если пара уже идёт для нашей группы (мы вошли во время пары) — начисляем посещение
                        if (class_in_session && current_group == group && !((group == 1) ? attended_this_session_ks40[student_id] : attended_this_session_ks44[student_id])) {
                            if (group == 1) { visits_ks40[student_id]++; attended_this_session_ks40[student_id] = true; }
                            else { visits_ks44[student_id]++; attended_this_session_ks44[student_id] = true; }
                            std::cout << "  (засчитано посещение для студента " << student_id << ", всего="
                                << (group == 1 ? visits_ks40[student_id] : visits_ks44[student_id]) << ")\n";
                        }

                        // Теперь мы либо в комнате и ждем начала пары, либо пара уже идёт нашей группы и мы ждём её окончания.
                        // У нас есть два сценария:
                        // 1) Если class_in_session && current_group == group -> ждём окончания пары
                        // 2) Если пара ещё не началась -> ждём начала в течение S секунд, иначе уходим на 1 сек и возвращаемся

                        // Сначала — если пара уже идёт нашей группы — просто дождаться её окончания:
                        if (class_in_session && current_group == group) {
                            // ждём знак окончания пары
                            cv.wait(lock, [this]() { return !this->class_in_session || this->stop_flag; });
                            // после окончания пара, учитель снимет in_room_* и уменьшит occupancy
                            // просто продолжаем цикл
                            continue;
                        }
                        else {
                            // пара ещё не началась — ждём до deadline или пока класс начнётся / кто-то вызовет notify
                            bool started = cv.wait_until(lock, deadline, [this, group]() {
                                return this->class_in_session || this->stop_flag;
                                });

                            if (stop_flag) return;

                            if (!started) {
                                // Таймаут — покидаем класс на 1 секунду, потом вернёмся (в соответствии с условием)
                                if (group == 1 && in_room_ks40[student_id]) {
                                    in_room_ks40[student_id] = false;
                                    present_ks40--;
                                    occupancy--;
                                }
                                else if (group == 2 && in_room_ks44[student_id]) {
                                    in_room_ks44[student_id] = false;
                                    present_ks44--;
                                    occupancy--;
                                }
                                std::cout << "Студент " << student_id << " из " << (group == 1 ? "КС-40" : "КС-44")
                                    << " не дождался начала (S=" << S << "s) — ушёл на 1s и вернётся\n";
                                // Разбудим других, потому что мы освободили место
                                lock.unlock();
                                cv.notify_all();
                                std::this_thread::sleep_for(std::chrono::seconds(1)); // уходит ровно на 1 сек
                                // затем просто продолжим внешний цикл и попробуем снова
                                break;
                            }
                            else {
                                // Началась пара — если она нашей группы, посещение уже начислено стартером или при входе
                                if (class_in_session && current_group == group) {
                                    // ждём окончания пары
                                    cv.wait(lock, [this]() { return !this->class_in_session || this->stop_flag; });
                                    if (stop_flag) return;
                                    // учитель снимет присутствующих - мы просто продолжаем
                                    continue;
                                }
                                else {
                                    // Началась пара другой группы — мы были (возможно) выгнаны в start_class_locked,
                                    // убедимся, что мы действительно не в комнате
                                    if (group == 1 && in_room_ks40[student_id]) {
                                        in_room_ks40[student_id] = false;
                                        present_ks40--;
                                        occupancy--;
                                    }
                                    else if (group == 2 && in_room_ks44[student_id]) {
                                        in_room_ks44[student_id] = false;
                                        present_ks44--;
                                        occupancy--;
                                    }
                                    std::cout << "Студент " << student_id << " из " << (group == 1 ? "КС-40" : "КС-44")
                                        << " был выгнан при старте занятия другой группы\n";
                                    // уведомим и вернёмся (sleep 1s before retry)
                                    lock.unlock();
                                    cv.notify_all();
                                    std::this_thread::sleep_for(std::chrono::seconds(1));
                                    break;
                                }
                            }
                        }
                    }
                    else {
                        // Не можем войти прямо сейчас: ждем оповещения или пока не случится stop
                        cv.wait(lock);
                    }
                } // конец while ожидания входа/начала
            } // конец блока unique_lock

            // Перед новой попыткой даём очень маленькую паузу, если не были внутри пары
            // (если мы только что завершили пара — цикл проверит visits и либо завершит поток)
            if (stop_flag) return;
        } // конец внешнего while
    }

    bool all_students_completed() {
        std::lock_guard<std::mutex> lock(mtx);
        for (int v : visits_ks40) if (v < 2) return false;
        for (int v : visits_ks44) if (v < 2) return false;
        return true;
    }

    void print_statistics() {
        std::lock_guard<std::mutex> lock(mtx);
        std::cout << "\n=== Итоговая статистика посещений ===\n";
        std::cout << "КС-40: ";
        for (int i = 0; i < total_ks40; ++i)
            std::cout << visits_ks40[i] << (i + 1 == total_ks40 ? "\n" : " ");
        std::cout << "КС-44: ";
        for (int i = 0; i < total_ks44; ++i)
            std::cout << visits_ks44[i] << (i + 1 == total_ks44 ? "\n" : " ");
    }
};

int main() {
    setlocale(LC_ALL, "Russian");

    ComputerRoom room;
    std::vector<std::thread> threads;

    // Потоки для КС-40
    for (int i = 0; i < 30; ++i) {
        threads.emplace_back([&room, i]() {
            room.student_behavior(1, i);
            });
    }

    // Потоки для КС-44
    for (int i = 0; i < 24; ++i) {
        threads.emplace_back([&room, i]() {
            room.student_behavior(2, i);
            });
    }

    // Ждём завершения всех студентов (с таймаутом на случай неисправности)
    auto start = std::chrono::steady_clock::now();
    while (!room.all_students_completed()) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        if (std::chrono::steady_clock::now() - start > std::chrono::seconds(200)) {
            std::cout << "Достигнут таймаут ожидания (120 секунд). Принудительная остановка.\n";
            break;
        }
    }

    room.stop();

    for (auto& t : threads) {
        if (t.joinable()) t.join();
    }

    room.print_statistics();

    std::cout << "Программа завершена.\n";
    return 0;
}
